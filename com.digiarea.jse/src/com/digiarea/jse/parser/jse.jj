options{  LOOKAHEAD = 1;  STATIC = false;  JAVA_UNICODE_ESCAPE = false;  UNICODE_INPUT = true;  COMMON_TOKEN_ACTION = true;  JDK_VERSION = "1.5";  TOKEN_FACTORY = "ASTParser.GTToken";  //DEBUG_PARSER = true;  //DEBUG_LOOKAHEAD = true;}PARSER_BEGIN(ASTParser)package com.digiarea.jse.parser;import java.util.*;import com.digiarea.jse.*;/**
 * <p>This class was generated automatically by javacc, do not edit.</p>
 * @author norb.beaver@digi-area.com
 */@SuppressWarnings({"unused", "serial"})public final class ASTParser {  public void reset(java.io.InputStream in) throws java.io.IOException {    reset(in, null);  }  public void reset(java.io.InputStream in, String encoding) throws java.io.IOException {    in.reset();    ReInit(in, encoding);    token_source.clearComments();  }   public static ClassOrInterfaceType toClassOrInterfaceType(NameExpr name) {		if (name instanceof QualifiedNameExpr) {			return toClassOrInterfaceType((QualifiedNameExpr) name);		} else {			return NodeFacade.ClassOrInterfaceType(name);		}	}	public static ClassOrInterfaceType toClassOrInterfaceType(			QualifiedNameExpr qName) {		NameExpr qualifier = qName.getQualifier();		if (Character.isUpperCase(qualifier.getName().charAt(0))) {			return NodeFacade.ClassOrInterfaceType(toClassOrInterfaceType(qualifier),					NodeFacade.NameExpr(qName.getName()));		}		return NodeFacade.ClassOrInterfaceType(qName);	}  private <T> List<T> add(List<T> list, T obj) {    if (list == null) {      list = new LinkedList<T>();    }    list.add(obj);    return list;  }  private <T> List<T> add(int pos, List<T> list, T obj) {    if (list == null) {      list = new LinkedList<T>();    }    list.add(pos, obj);    return list;  }  private class Modifier {    final int modifiers;    final List<AnnotationExpr> annotations;    public Modifier(int modifiers, List<AnnotationExpr> annotations) {      this.modifiers = modifiers;      this.annotations = annotations;    }  }  private class ArrayDimsAndInits {    final List<ArraySlot> slots;    final ArrayInitializerExpr initializer;	public ArrayDimsAndInits(List<ArraySlot> slots, ArrayInitializerExpr initializer) {	  this.slots = slots;      this.initializer = initializer;	}      }  public int addModifier(int modifiers, int mod, Token token)  	throws ParseException {    if ((Modifiers.hasModifier(modifiers, mod))) {      throwParseException(token, "Duplicated modifier");    }    return Modifiers.addModifier(modifiers, mod);  }  private void pushJavadoc() {    token_source.pushJavadoc();  }  private JavadocComment popJavadoc() {    return token_source.popJavadoc();  }  private List<Comment> getComments() {    return token_source.getComments();  }  private void throwParseException(Token token, String message)  	throws ParseException {    StringBuilder buf = new StringBuilder();    buf.append("\n");    buf.append(message);    buf.append(": \"");    buf.append(token.image);    buf.append("\" at line ");    buf.append(token.beginLine);    buf.append(", column ");    buf.append(token.beginColumn);    ParseException e = new ParseException(buf.toString());    e.currentToken = token;    throw e;  }  static final class GTToken extends Token {    int realKind = ASTParserConstants.GT;    GTToken(int kind, String image) {      this.kind = kind;      this.image = image;    }    public static Token newToken(int kind, String image) {      return new GTToken(kind, image);    }  }  }PARSER_END(ASTParser)/* WHITE SPACE */SKIP :{  " "| "\t"| "\n"| "\r"| "\f"}/* COMMENTS */TOKEN_MGR_DECLS :{  private List<Comment> comments;  private final Stack<JavadocComment> javadocStack = new Stack<JavadocComment> ();  private JavadocComment lastJavadoc;  void pushJavadoc()  {    javadocStack.push(lastJavadoc);  }  JavadocComment popJavadoc()  {    if (javadocStack.empty())    {      return null;    } else    {      return javadocStack.pop();    }  }  List<Comment> getComments()  {    return comments;  }  void clearComments()  {    comments = null;    javadocStack.clear();    lastJavadoc = null;  }  private void CommonTokenAction(Token token)  {    lastJavadoc = null;    if (token.specialToken != null)    {      if (comments == null)      {        comments = new LinkedList<Comment>();      }      Token special = token.specialToken;      if (special.kind == JAVA_DOC_COMMENT)      {        lastJavadoc = NodeFacade.JavadocComment(special.image.substring(3, special.image.length() - 2));        comments.add(lastJavadoc);      }      else if (special.kind == SINGLE_LINE_COMMENT)      {        LineComment comment = NodeFacade.LineComment(special.image.substring(2));        comments.add(comment);      }      else if (special.kind == MULTI_LINE_COMMENT)      {        BlockComment comment = NodeFacade.BlockComment(special.image.substring(2, special.image.length() - 2));        comments.add(comment);      }    }  }  /** Fake getter :) */  int getLengthOfMatch() {    return lengthOfMatch;  }  }SPECIAL_TOKEN :{  < SINGLE_LINE_COMMENT :    "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? >}MORE :{  < "/**" ~[ "/" ] >  {    input_stream.backup(1);  }  : IN_JAVA_DOC_COMMENT| < "/*" > : IN_MULTI_LINE_COMMENT}< IN_JAVA_DOC_COMMENT >SPECIAL_TOKEN :{  < JAVA_DOC_COMMENT : "*/" > : DEFAULT}< IN_MULTI_LINE_COMMENT >SPECIAL_TOKEN :{  < MULTI_LINE_COMMENT : "*/" > : DEFAULT}< IN_JAVA_DOC_COMMENT, IN_MULTI_LINE_COMMENT >MORE :{  < ~[ ] >}/* RESERVED WORDS AND LITERALS */TOKEN :{  < ABSTRACT : "abstract" >| < ASSERT : "assert" >| < BOOLEAN : "boolean" >| < BREAK : "break" >| < BYTE : "byte" >| < CASE : "case" >| < CATCH : "catch" >| < CHAR : "char" >| < CLASS : "class" >| < CONST : "const" >| < CONTINUE : "continue" >| < _DEFAULT : "default" >| < DO : "do" >| < DOUBLE : "double" >| < ELSE : "else" >| < ENUM : "enum" >| < EXTENDS : "extends" >| < FALSE : "false" >| < FINAL : "final" >| < FINALLY : "finally" >| < FLOAT : "float" >| < FOR : "for" >| < GOTO : "goto" >| < IF : "if" >| < IMPLEMENTS : "implements" >| < IMPORT : "import" >| < INSTANCEOF : "instanceof" >| < INT : "int" >| < INTERFACE : "interface" >| < LONG : "long" >| < NATIVE : "native" >| < NEW : "new" >| < NULL : "null" >| < PACKAGE : "package" >| < PRIVATE : "private" >| < PROTECTED : "protected" >| < PUBLIC : "public" >| < RETURN : "return" >| < SHORT : "short" >| < STATIC : "static" >| < STRICTFP : "strictfp" >| < SUPER : "super" >| < SWITCH : "switch" >| < SYNCHRONIZED : "synchronized" >| < THIS : "this" >| < THROW : "throw" >| < THROWS : "throws" >| < TRANSIENT : "transient" >| < TRUE : "true" >| < TRY : "try" >| < VOID : "void" >| < VOLATILE : "volatile" >| < WHILE : "while" >}/* LITERALS */TOKEN :{  < LONG_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])  | < HEX_LITERAL > ([ "l", "L" ])  | < OCTAL_LITERAL > ([ "l", "L" ])  | < BINARY_LITERAL > ([ "l", "L" ]) >| < INTEGER_LITERAL :    < DECIMAL_LITERAL >  | < HEX_LITERAL >  | < OCTAL_LITERAL >  | < BINARY_LITERAL > >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9", "_" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F", "_" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7", "_" ])* >| < #BINARY_LITERAL : "0" [ "b", "B" ] ([ "0"-"1", "_" ])+ >| < FLOATING_POINT_LITERAL :    < DECIMAL_FLOATING_POINT_LITERAL >  | < HEXADECIMAL_FLOATING_POINT_LITERAL > >| < #DECIMAL_FLOATING_POINT_LITERAL :    ([ "0"-"9" ]) ([ "0"-"9", "_" ])* "." ([ "0"-"9" ])? ([ "0"-"9", "_" ])* (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ]) ([ "0"-"9", "_" ])* (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ]) ([ "0"-"9", "_" ])* < DECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ]) ([ "0"-"9", "_" ])* (< DECIMAL_EXPONENT >)? [ "f", "F", "d", "D" ] >| < #DECIMAL_EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < #HEXADECIMAL_FLOATING_POINT_LITERAL :    "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F", "_" ])+ (".")? < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F", "_" ])* "." ([ "0"-"9", "a"-"f", "A"-"F"]) ([ "0"-"9", "a"-"f", "A"-"F", "_" ])* < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])? >| < #HEXADECIMAL_EXPONENT : [ "p", "P" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < CHARACTER_LITERAL :    "'"    (      (~[ "'", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    | ("\\u" [ "0"-"9", "A"-"F", "a"-"f" ] [ "0"-"9", "A"-"F", "a"-"f" ] [ "0"-"9", "A"-"F", "a"-"f" ] [ "0"-"9", "A"-"F", "a"-"f" ] ([ "n", "t", "b", "r", "f", "\\", "'", "\"" ])?)    )    "'" >| < STRING_LITERAL :    "\""    (      (~[ "\"", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    | ("\\u" [ "0"-"9", "A"-"F", "a"-"f" ] [ "0"-"9", "A"-"F", "a"-"f" ] [ "0"-"9", "A"-"F", "a"-"f" ] [ "0"-"9", "A"-"F", "a"-"f" ])    )*    "\"" >}/* IDENTIFIERS */TOKEN :{  < IDENTIFIER : < LETTER > (< PART_LETTER >)* >| < #LETTER : [ // all chars for which Character.isIdentifierStart is true
    "\u0024", // "$"
    "\u0041"-"\u005a", // "A"-"Z"
    "\u005f", // "_"
    "\u0061"-"\u007a", // "a"-"z"
    "\u00a2"-"\u00a5", "\u00aa", "\u00b5", "\u00ba", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u0236", "\u0250"-"\u02c1", "\u02c6"-"\u02d1", "\u02e0"-"\u02e4", "\u02ee", "\u037a", "\u0386", "\u0388"-"\u038a", "\u038c", "\u038e"-"\u03a1", "\u03a3"-"\u03ce", "\u03d0"-"\u03f5", "\u03f7"-"\u03fb", "\u0400"-"\u0481", "\u048a"-"\u04ce", "\u04d0"-"\u04f5", "\u04f8"-"\u04f9", "\u0500"-"\u050f", "\u0531"-"\u0556", "\u0559", "\u0561"-"\u0587", "\u05d0"-"\u05ea", "\u05f0"-"\u05f2", "\u0621"-"\u063a", "\u0640"-"\u064a", "\u066e"-"\u066f", "\u0671"-"\u06d3", "\u06d5", "\u06e5"-"\u06e6", "\u06ee"-"\u06ef", "\u06fa"-"\u06fc", "\u06ff", "\u0710", "\u0712"-"\u072f", "\u074d"-"\u074f", "\u0780"-"\u07a5", "\u07b1", "\u0904"-"\u0939", "\u093d", "\u0950", "\u0958"-"\u0961", "\u0985"-"\u098c", "\u098f"-"\u0990", "\u0993"-"\u09a8", "\u09aa"-"\u09b0", "\u09b2", "\u09b6"-"\u09b9", "\u09bd", "\u09dc"-"\u09dd", "\u09df"-"\u09e1", "\u09f0"-"\u09f3", "\u0a05"-"\u0a0a", "\u0a0f"-"\u0a10", "\u0a13"-"\u0a28", "\u0a2a"-"\u0a30", "\u0a32"-"\u0a33", "\u0a35"-"\u0a36", "\u0a38"-"\u0a39", "\u0a59"-"\u0a5c", "\u0a5e", "\u0a72"-"\u0a74", "\u0a85"-"\u0a8d", "\u0a8f"-"\u0a91", "\u0a93"-"\u0aa8", "\u0aaa"-"\u0ab0", "\u0ab2"-"\u0ab3", "\u0ab5"-"\u0ab9", "\u0abd", "\u0ad0", "\u0ae0"-"\u0ae1", "\u0af1", "\u0b05"-"\u0b0c", "\u0b0f"-"\u0b10", "\u0b13"-"\u0b28", "\u0b2a"-"\u0b30", "\u0b32"-"\u0b33", "\u0b35"-"\u0b39", "\u0b3d", "\u0b5c"-"\u0b5d", "\u0b5f"-"\u0b61", "\u0b71", "\u0b83", "\u0b85"-"\u0b8a", "\u0b8e"-"\u0b90", "\u0b92"-"\u0b95", "\u0b99"-"\u0b9a", "\u0b9c", "\u0b9e"-"\u0b9f", "\u0ba3"-"\u0ba4", "\u0ba8"-"\u0baa", "\u0bae"-"\u0bb5", "\u0bb7"-"\u0bb9", "\u0bf9", "\u0c05"-"\u0c0c", "\u0c0e"-"\u0c10", "\u0c12"-"\u0c28", "\u0c2a"-"\u0c33", "\u0c35"-"\u0c39", "\u0c60"-"\u0c61", "\u0c85"-"\u0c8c", "\u0c8e"-"\u0c90", "\u0c92"-"\u0ca8", "\u0caa"-"\u0cb3", "\u0cb5"-"\u0cb9", "\u0cbd", "\u0cde", "\u0ce0"-"\u0ce1", "\u0d05"-"\u0d0c", "\u0d0e"-"\u0d10", "\u0d12"-"\u0d28", "\u0d2a"-"\u0d39", "\u0d60"-"\u0d61", "\u0d85"-"\u0d96", "\u0d9a"-"\u0db1", "\u0db3"-"\u0dbb", "\u0dbd", "\u0dc0"-"\u0dc6", "\u0e01"-"\u0e30", "\u0e32"-"\u0e33", "\u0e3f"-"\u0e46", "\u0e81"-"\u0e82", "\u0e84", "\u0e87"-"\u0e88", "\u0e8a", "\u0e8d", "\u0e94"-"\u0e97", "\u0e99"-"\u0e9f", "\u0ea1"-"\u0ea3", "\u0ea5", "\u0ea7", "\u0eaa"-"\u0eab", "\u0ead"-"\u0eb0", "\u0eb2"-"\u0eb3", "\u0ebd", "\u0ec0"-"\u0ec4", "\u0ec6", "\u0edc"-"\u0edd", "\u0f00", "\u0f40"-"\u0f47", "\u0f49"-"\u0f6a", "\u0f88"-"\u0f8b", "\u1000"-"\u1021", "\u1023"-"\u1027", "\u1029"-"\u102a", "\u1050"-"\u1055", "\u10a0"-"\u10c5", "\u10d0"-"\u10f8", "\u1100"-"\u1159", "\u115f"-"\u11a2", "\u11a8"-"\u11f9", "\u1200"-"\u1206", "\u1208"-"\u1246", "\u1248", "\u124a"-"\u124d", "\u1250"-"\u1256", "\u1258", "\u125a"-"\u125d", "\u1260"-"\u1286", "\u1288", "\u128a"-"\u128d", "\u1290"-"\u12ae", "\u12b0", "\u12b2"-"\u12b5", "\u12b8"-"\u12be", "\u12c0", "\u12c2"-"\u12c5", "\u12c8"-"\u12ce", "\u12d0"-"\u12d6", "\u12d8"-"\u12ee", "\u12f0"-"\u130e", "\u1310", "\u1312"-"\u1315", "\u1318"-"\u131e", "\u1320"-"\u1346", "\u1348"-"\u135a", "\u13a0"-"\u13f4", "\u1401"-"\u166c", "\u166f"-"\u1676", "\u1681"-"\u169a", "\u16a0"-"\u16ea", "\u16ee"-"\u16f0", "\u1700"-"\u170c", "\u170e"-"\u1711", "\u1720"-"\u1731", "\u1740"-"\u1751", "\u1760"-"\u176c", "\u176e"-"\u1770", "\u1780"-"\u17b3", "\u17d7", "\u17db"-"\u17dc", "\u1820"-"\u1877", "\u1880"-"\u18a8", "\u1900"-"\u191c", "\u1950"-"\u196d", "\u1970"-"\u1974", "\u1d00"-"\u1d6b", "\u1e00"-"\u1e9b", "\u1ea0"-"\u1ef9", "\u1f00"-"\u1f15", "\u1f18"-"\u1f1d", "\u1f20"-"\u1f45", "\u1f48"-"\u1f4d", "\u1f50"-"\u1f57", "\u1f59", "\u1f5b", "\u1f5d", "\u1f5f"-"\u1f7d", "\u1f80"-"\u1fb4", "\u1fb6"-"\u1fbc", "\u1fbe", "\u1fc2"-"\u1fc4", "\u1fc6"-"\u1fcc", "\u1fd0"-"\u1fd3", "\u1fd6"-"\u1fdb", "\u1fe0"-"\u1fec", "\u1ff2"-"\u1ff4", "\u1ff6"-"\u1ffc", "\u203f"-"\u2040", "\u2054", "\u2071", "\u207f", "\u20a0"-"\u20b1", "\u2102", "\u2107", "\u210a"-"\u2113", "\u2115", "\u2119"-"\u211d", "\u2124", "\u2126", "\u2128", "\u212a"-"\u212d", "\u212f"-"\u2131", "\u2133"-"\u2139", "\u213d"-"\u213f", "\u2145"-"\u2149", "\u2160"-"\u2183", "\u3005"-"\u3007", "\u3021"-"\u3029", "\u3031"-"\u3035", "\u3038"-"\u303c", "\u3041"-"\u3096", "\u309d"-"\u309f", "\u30a1"-"\u30ff", "\u3105"-"\u312c", "\u3131"-"\u318e", "\u31a0"-"\u31b7", "\u31f0"-"\u31ff", "\u3400"-"\u4db5", "\u4e00"-"\u9fa5", "\ua000"-"\ua48c", "\uac00"-"\ud7a3", "\ud801", //for supplementary characters suport
    "\ud802", //for supplementary characters suport
    "\uf900"-"\ufa2d", "\ufa30"-"\ufa6a", "\ufb00"-"\ufb06", "\ufb13"-"\ufb17", "\ufb1d", "\ufb1f"-"\ufb28", "\ufb2a"-"\ufb36", "\ufb38"-"\ufb3c", "\ufb3e", "\ufb40"-"\ufb41", "\ufb43"-"\ufb44", "\ufb46"-"\ufbb1", "\ufbd3"-"\ufd3d", "\ufd50"-"\ufd8f", "\ufd92"-"\ufdc7", "\ufdf0"-"\ufdfc", "\ufe33"-"\ufe34", "\ufe4d"-"\ufe4f", "\ufe69", "\ufe70"-"\ufe74", "\ufe76"-"\ufefc", "\uff04", "\uff21"-"\uff3a", "\uff3f", "\uff41"-"\uff5a", "\uff65"-"\uffbe", "\uffc2"-"\uffc7", "\uffca"-"\uffcf", "\uffd2"-"\uffd7", "\uffda"-"\uffdc", "\uffe0"-"\uffe1", "\uffe5"-"\uffe6" ] >| < #PART_LETTER : [ // all chars for which Character.isIdentifierPart is true
    "\u0000"-"\u0008", "\u000e"-"\u001b", "\u0024", // "$"
    "\u0030"-"\u0039", // "0"-"9"
    "\u0041"-"\u005a", // "A"-"Z"
    "\u005f", // "_"
    "\u0061"-"\u007a", // "a"-"z"
    "\u007f"-"\u009f", "\u00a2"-"\u00a5", "\u00aa", "\u00ad", "\u00b5", "\u00ba", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u0236", "\u0250"-"\u02c1", "\u02c6"-"\u02d1", "\u02e0"-"\u02e4", "\u02ee", "\u0300"-"\u0357", "\u035d"-"\u036f", "\u037a", "\u0386", "\u0388"-"\u038a", "\u038c", "\u038e"-"\u03a1", "\u03a3"-"\u03ce", "\u03d0"-"\u03f5", "\u03f7"-"\u03fb", "\u0400"-"\u0481", "\u0483"-"\u0486", "\u048a"-"\u04ce", "\u04d0"-"\u04f5", "\u04f8"-"\u04f9", "\u0500"-"\u050f", "\u0531"-"\u0556", "\u0559", "\u0561"-"\u0587", "\u0591"-"\u05a1", "\u05a3"-"\u05b9", "\u05bb"-"\u05bd", "\u05bf", "\u05c1"-"\u05c2", "\u05c4", "\u05d0"-"\u05ea", "\u05f0"-"\u05f2", "\u0600"-"\u0603", "\u0610"-"\u0615", "\u0621"-"\u063a", "\u0640"-"\u0658", "\u0660"-"\u0669", "\u066e"-"\u06d3", "\u06d5"-"\u06dd", "\u06df"-"\u06e8", "\u06ea"-"\u06fc", "\u06ff", "\u070f"-"\u074a", "\u074d"-"\u074f", "\u0780"-"\u07b1", "\u0901"-"\u0939", "\u093c"-"\u094d", "\u0950"-"\u0954", "\u0958"-"\u0963", "\u0966"-"\u096f", "\u0981"-"\u0983", "\u0985"-"\u098c", "\u098f"-"\u0990", "\u0993"-"\u09a8", "\u09aa"-"\u09b0", "\u09b2", "\u09b6"-"\u09b9", "\u09bc"-"\u09c4", "\u09c7"-"\u09c8", "\u09cb"-"\u09cd", "\u09d7", "\u09dc"-"\u09dd", "\u09df"-"\u09e3", "\u09e6"-"\u09f3", "\u0a01"-"\u0a03", "\u0a05"-"\u0a0a", "\u0a0f"-"\u0a10", "\u0a13"-"\u0a28", "\u0a2a"-"\u0a30", "\u0a32"-"\u0a33", "\u0a35"-"\u0a36", "\u0a38"-"\u0a39", "\u0a3c", "\u0a3e"-"\u0a42", "\u0a47"-"\u0a48", "\u0a4b"-"\u0a4d", "\u0a59"-"\u0a5c", "\u0a5e", "\u0a66"-"\u0a74", "\u0a81"-"\u0a83", "\u0a85"-"\u0a8d", "\u0a8f"-"\u0a91", "\u0a93"-"\u0aa8", "\u0aaa"-"\u0ab0", "\u0ab2"-"\u0ab3", "\u0ab5"-"\u0ab9", "\u0abc"-"\u0ac5", "\u0ac7"-"\u0ac9", "\u0acb"-"\u0acd", "\u0ad0", "\u0ae0"-"\u0ae3", "\u0ae6"-"\u0aef", "\u0af1", "\u0b01"-"\u0b03", "\u0b05"-"\u0b0c", "\u0b0f"-"\u0b10", "\u0b13"-"\u0b28", "\u0b2a"-"\u0b30", "\u0b32"-"\u0b33", "\u0b35"-"\u0b39", "\u0b3c"-"\u0b43", "\u0b47"-"\u0b48", "\u0b4b"-"\u0b4d", "\u0b56"-"\u0b57", "\u0b5c"-"\u0b5d", "\u0b5f"-"\u0b61", "\u0b66"-"\u0b6f", "\u0b71", "\u0b82"-"\u0b83", "\u0b85"-"\u0b8a", "\u0b8e"-"\u0b90", "\u0b92"-"\u0b95", "\u0b99"-"\u0b9a", "\u0b9c", "\u0b9e"-"\u0b9f", "\u0ba3"-"\u0ba4", "\u0ba8"-"\u0baa", "\u0bae"-"\u0bb5", "\u0bb7"-"\u0bb9", "\u0bbe"-"\u0bc2", "\u0bc6"-"\u0bc8", "\u0bca"-"\u0bcd", "\u0bd7", "\u0be7"-"\u0bef", "\u0bf9", "\u0c01"-"\u0c03", "\u0c05"-"\u0c0c", "\u0c0e"-"\u0c10", "\u0c12"-"\u0c28", "\u0c2a"-"\u0c33", "\u0c35"-"\u0c39", "\u0c3e"-"\u0c44", "\u0c46"-"\u0c48", "\u0c4a"-"\u0c4d", "\u0c55"-"\u0c56", "\u0c60"-"\u0c61", "\u0c66"-"\u0c6f", "\u0c82"-"\u0c83", "\u0c85"-"\u0c8c", "\u0c8e"-"\u0c90", "\u0c92"-"\u0ca8", "\u0caa"-"\u0cb3", "\u0cb5"-"\u0cb9", "\u0cbc"-"\u0cc4", "\u0cc6"-"\u0cc8", "\u0cca"-"\u0ccd", "\u0cd5"-"\u0cd6", "\u0cde", "\u0ce0"-"\u0ce1", "\u0ce6"-"\u0cef", "\u0d02"-"\u0d03", "\u0d05"-"\u0d0c", "\u0d0e"-"\u0d10", "\u0d12"-"\u0d28", "\u0d2a"-"\u0d39", "\u0d3e"-"\u0d43", "\u0d46"-"\u0d48", "\u0d4a"-"\u0d4d", "\u0d57", "\u0d60"-"\u0d61", "\u0d66"-"\u0d6f", "\u0d82"-"\u0d83", "\u0d85"-"\u0d96", "\u0d9a"-"\u0db1", "\u0db3"-"\u0dbb", "\u0dbd", "\u0dc0"-"\u0dc6", "\u0dca", "\u0dcf"-"\u0dd4", "\u0dd6", "\u0dd8"-"\u0ddf", "\u0df2"-"\u0df3", "\u0e01"-"\u0e3a", "\u0e3f"-"\u0e4e", "\u0e50"-"\u0e59", "\u0e81"-"\u0e82", "\u0e84", "\u0e87"-"\u0e88", "\u0e8a", "\u0e8d", "\u0e94"-"\u0e97", "\u0e99"-"\u0e9f", "\u0ea1"-"\u0ea3", "\u0ea5", "\u0ea7", "\u0eaa"-"\u0eab", "\u0ead"-"\u0eb9", "\u0ebb"-"\u0ebd", "\u0ec0"-"\u0ec4", "\u0ec6", "\u0ec8"-"\u0ecd", "\u0ed0"-"\u0ed9", "\u0edc"-"\u0edd", "\u0f00", "\u0f18"-"\u0f19", "\u0f20"-"\u0f29", "\u0f35", "\u0f37", "\u0f39", "\u0f3e"-"\u0f47", "\u0f49"-"\u0f6a", "\u0f71"-"\u0f84", "\u0f86"-"\u0f8b", "\u0f90"-"\u0f97", "\u0f99"-"\u0fbc", "\u0fc6", "\u1000"-"\u1021", "\u1023"-"\u1027", "\u1029"-"\u102a", "\u102c"-"\u1032", "\u1036"-"\u1039", "\u1040"-"\u1049", "\u1050"-"\u1059", "\u10a0"-"\u10c5", "\u10d0"-"\u10f8", "\u1100"-"\u1159", "\u115f"-"\u11a2", "\u11a8"-"\u11f9", "\u1200"-"\u1206", "\u1208"-"\u1246", "\u1248", "\u124a"-"\u124d", "\u1250"-"\u1256", "\u1258", "\u125a"-"\u125d", "\u1260"-"\u1286", "\u1288", "\u128a"-"\u128d", "\u1290"-"\u12ae", "\u12b0", "\u12b2"-"\u12b5", "\u12b8"-"\u12be", "\u12c0", "\u12c2"-"\u12c5", "\u12c8"-"\u12ce", "\u12d0"-"\u12d6", "\u12d8"-"\u12ee", "\u12f0"-"\u130e", "\u1310", "\u1312"-"\u1315", "\u1318"-"\u131e", "\u1320"-"\u1346", "\u1348"-"\u135a", "\u1369"-"\u1371", "\u13a0"-"\u13f4", "\u1401"-"\u166c", "\u166f"-"\u1676", "\u1681"-"\u169a", "\u16a0"-"\u16ea", "\u16ee"-"\u16f0", "\u1700"-"\u170c", "\u170e"-"\u1714", "\u1720"-"\u1734", "\u1740"-"\u1753", "\u1760"-"\u176c", "\u176e"-"\u1770", "\u1772"-"\u1773", "\u1780"-"\u17d3", "\u17d7", "\u17db"-"\u17dd", "\u17e0"-"\u17e9", "\u180b"-"\u180d", "\u1810"-"\u1819", "\u1820"-"\u1877", "\u1880"-"\u18a9", "\u1900"-"\u191c", "\u1920"-"\u192b", "\u1930"-"\u193b", "\u1946"-"\u196d", "\u1970"-"\u1974", "\u1d00"-"\u1d6b", "\u1e00"-"\u1e9b", "\u1ea0"-"\u1ef9", "\u1f00"-"\u1f15", "\u1f18"-"\u1f1d", "\u1f20"-"\u1f45", "\u1f48"-"\u1f4d", "\u1f50"-"\u1f57", "\u1f59", "\u1f5b", "\u1f5d", "\u1f5f"-"\u1f7d", "\u1f80"-"\u1fb4", "\u1fb6"-"\u1fbc", "\u1fbe", "\u1fc2"-"\u1fc4", "\u1fc6"-"\u1fcc", "\u1fd0"-"\u1fd3", "\u1fd6"-"\u1fdb", "\u1fe0"-"\u1fec", "\u1ff2"-"\u1ff4", "\u1ff6"-"\u1ffc", "\u200c"-"\u200f", "\u202a"-"\u202e", "\u203f"-"\u2040", "\u2054", "\u2060"-"\u2063", "\u206a"-"\u206f", "\u2071", "\u207f", "\u20a0"-"\u20b1", "\u20d0"-"\u20dc", "\u20e1", "\u20e5"-"\u20ea", "\u2102", "\u2107", "\u210a"-"\u2113", "\u2115", "\u2119"-"\u211d", "\u2124", "\u2126", "\u2128", "\u212a"-"\u212d", "\u212f"-"\u2131", "\u2133"-"\u2139", "\u213d"-"\u213f", "\u2145"-"\u2149", "\u2160"-"\u2183", "\u3005"-"\u3007", "\u3021"-"\u302f", "\u3031"-"\u3035", "\u3038"-"\u303c", "\u3041"-"\u3096", "\u3099"-"\u309a", "\u309d"-"\u309f", "\u30a1"-"\u30ff", "\u3105"-"\u312c", "\u3131"-"\u318e", "\u31a0"-"\u31b7", "\u31f0"-"\u31ff", "\u3400"-"\u4db5", "\u4e00"-"\u9fa5", "\ua000"-"\ua48c", "\uac00"-"\ud7a3", "\ud801", //for supplementary characters suport
    "\ud802", //for supplementary characters suport
    "\ud834", //for supplementary characters suport
    "\udc00", //for supplementary characters suport
    "\udc01", //for supplementary characters suport
    "\udd7b", //for supplementary characters suport
    "\uf900"-"\ufa2d", "\ufa30"-"\ufa6a", "\ufb00"-"\ufb06", "\ufb13"-"\ufb17", "\ufb1d"-"\ufb28", "\ufb2a"-"\ufb36", "\ufb38"-"\ufb3c", "\ufb3e", "\ufb40"-"\ufb41", "\ufb43"-"\ufb44", "\ufb46"-"\ufbb1", "\ufbd3"-"\ufd3d", "\ufd50"-"\ufd8f", "\ufd92"-"\ufdc7", "\ufdf0"-"\ufdfc", "\ufe00"-"\ufe0f", "\ufe20"-"\ufe23", "\ufe33"-"\ufe34", "\ufe4d"-"\ufe4f", "\ufe69", "\ufe70"-"\ufe74", "\ufe76"-"\ufefc", "\ufeff", "\uff04", "\uff10"-"\uff19", "\uff21"-"\uff3a", "\uff3f", "\uff41"-"\uff5a", "\uff65"-"\uffbe", "\uffc2"-"\uffc7", "\uffca"-"\uffcf", "\uffd2"-"\uffd7", "\uffda"-"\uffdc", "\uffe0"-"\uffe1", "\uffe5"-"\uffe6", "\ufff9"-"\ufffb" ] >}/* SEPARATORS */TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >| < AT : "@" >}/* OPERATORS */TOKEN :{  < ASSIGN : "=" >| < LT : "<" >| < BANG : "!" >| < TILDE : "~" >| < HOOK : "?" >| < COLON : ":" >| < EQ : "==" >| < LE : "<=" >| < GE : ">=" >| < NE : "!=" >| < SC_OR : "||" >| < SC_AND : "&&" >| < INCR : "++" >| < DECR : "--" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < BIT_AND : "&" >| < BIT_OR : "|" >| < XOR : "^" >| < REM : "%" >| < LSHIFT : "<<" >| < PLUSASSIGN : "+=" >| < MINUSASSIGN : "-=" >| < STARASSIGN : "*=" >| < SLASHASSIGN : "/=" >| < ANDASSIGN : "&=" >| < ORASSIGN : "|=" >| < XORASSIGN : "^=" >| < REMASSIGN : "%=" >| < LSHIFTASSIGN : "<<=" >| < RSIGNEDSHIFTASSIGN : ">>=" >| < RUNSIGNEDSHIFTASSIGN : ">>>=" >| < ELLIPSIS : "..." >}/* >'s need special attention due to generics syntax. */TOKEN :{  < RUNSIGNEDSHIFT : ">>>" >  {    matchedToken.kind = GT;    ((ASTParser.GTToken) matchedToken).realKind = RUNSIGNEDSHIFT;    input_stream.backup(2);  }| < RSIGNEDSHIFT : ">>" >  {    matchedToken.kind = GT;    ((ASTParser.GTToken) matchedToken).realKind = RSIGNEDSHIFT;    input_stream.backup(1);  }| < GT : ">" >}/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************//*
 * Program structuring syntax follows.
 */CompilationUnit CompilationUnit() :{  PackageDeclaration pakage = null;  List<ImportDeclaration> imports = null;  ImportDeclaration in = null;  List<TypeDeclaration> types = null;  TypeDeclaration tn = null;}{  [    LOOKAHEAD(PackageDeclaration())    pakage = PackageDeclaration()  ]  (    in = ImportDeclaration()    {      imports = add(imports, in);    }  )*  (    tn = TypeDeclaration()    {      types = add(types, tn);    }  )*  (    < EOF >  | "\u001A" /** ctrl+z char **/  )  {    return NodeFacade.CompilationUnit(pakage, imports, types, getComments(), null);  }}PackageDeclaration PackageDeclaration() :{  List<AnnotationExpr> annotations = null;  AnnotationExpr ann;  NameExpr name;}{  (    ann = Annotation()    {      annotations = add(annotations, ann);    }  )*  "package" name = Name() ";"  {    return NodeFacade.PackageDeclaration(name, annotations);  }}ImportDeclaration ImportDeclaration() :{  NameExpr name;  boolean isStatic = false;  boolean isAsterisk = false;}{  "import"  [    "static"    {      isStatic = true;    }  ]  name = Name()  [    "." "*"    {      isAsterisk = true;    }  ]  ";"  {    return NodeFacade.ImportDeclaration(name, isStatic, isAsterisk);  }}/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */Modifier Modifiers() :{  int modifiers = 0;  List<AnnotationExpr> annotations = null;  AnnotationExpr ann;}{  (    LOOKAHEAD(2)    (      "public"      {        modifiers = addModifier(modifiers, Modifiers.PUBLIC, token);      }    | "static"      {        modifiers = addModifier(modifiers, Modifiers.STATIC, token);      }    | "protected"      {        modifiers = addModifier(modifiers, Modifiers.PROTECTED, token);      }    | "private"      {        modifiers = addModifier(modifiers, Modifiers.PRIVATE, token);      }    | "final"      {        modifiers = addModifier(modifiers, Modifiers.FINAL, token);      }    | "abstract"      {        modifiers = addModifier(modifiers, Modifiers.ABSTRACT, token);      }    | "synchronized"      {        modifiers = addModifier(modifiers, Modifiers.SYNCHRONIZED, token);      }    | "native"      {        modifiers = addModifier(modifiers, Modifiers.NATIVE, token);      }    | "transient"      {        modifiers = addModifier(modifiers, Modifiers.TRANSIENT, token);      }    | "volatile"      {        modifiers = addModifier(modifiers, Modifiers.VOLATILE, token);      }    | "strictfp"      {        modifiers = addModifier(modifiers, Modifiers.STRICTFP, token);      }    | ann = Annotation()      {        annotations = add(annotations, ann);      }    )  )*  {    return new Modifier(modifiers, annotations);  }}Modifier TypeDeclModifiers() :{  int modifiers = 0;  List<AnnotationExpr> annotations = null;  AnnotationExpr ann;}{  (    LOOKAHEAD(2)    (      "public"      {        modifiers = addModifier(modifiers, Modifiers.PUBLIC, token);      }    | "static"      {        modifiers = addModifier(modifiers, Modifiers.STATIC, token);      }    | "protected"      {        modifiers = addModifier(modifiers, Modifiers.PROTECTED, token);      }    | "private"      {        modifiers = addModifier(modifiers, Modifiers.PRIVATE, token);      }    | "final"      {        modifiers = addModifier(modifiers, Modifiers.FINAL, token);      }    | "abstract"      {        modifiers = addModifier(modifiers, Modifiers.ABSTRACT, token);      }    | "synchronized"      {        modifiers = addModifier(modifiers, Modifiers.SYNCHRONIZED, token);      }    | "native"      {        modifiers = addModifier(modifiers, Modifiers.NATIVE, token);      }    | "transient"      {        modifiers = addModifier(modifiers, Modifiers.TRANSIENT, token);      }    | "volatile"      {        modifiers = addModifier(modifiers, Modifiers.VOLATILE, token);      }    | "strictfp"      {        modifiers = addModifier(modifiers, Modifiers.STRICTFP, token);      }    | "default"      {        modifiers = addModifier(modifiers, Modifiers.DEFAULT, token);      }    | ann = Annotation()      {        annotations = add(annotations, ann);      }    )  )*  {    return new Modifier(modifiers, annotations);  }}/*
 * Declaration syntax follows.
 */TypeDeclaration TypeDeclaration() :{  Modifier modifier;  TypeDeclaration ret;}{  {    pushJavadoc();  }  (    ";"    {      ret = NodeFacade.EmptyTypeDeclaration(popJavadoc());    }  | modifier = Modifiers()    (      ret = ClassOrInterfaceDeclaration(modifier)    | ret = EnumDeclaration(modifier)    | ret = AnnotationTypeDeclaration(modifier)    )  )  {    return ret;  }}TypeDeclaration ClassOrInterfaceDeclaration(Modifier modifier) :{  TypeDeclaration typeDecl;}{  (    typeDecl = ClassDeclaration(modifier)  | typeDecl = InterfaceDeclaration(modifier)  )  {    return typeDecl;  }}ClassDeclaration ClassDeclaration(Modifier modifier) :{  String name = null;  List<TypeParameter> typePar = null;  List<ClassOrInterfaceType> extList = null;  List<ClassOrInterfaceType> impList = null;  List<BodyDeclaration> members = null;}{  "class" < IDENTIFIER >  {    name = token.image;  }  [ typePar = TypeParameters() ] [ extList = ExtendsList(false) ] [ impList = ImplementsList(false) ] members = ClassOrInterfaceBody(false)  {    return NodeFacade.ClassDeclaration(typePar, (ClassOrInterfaceType) (extList != null ? extList.get(0) : null),    	impList, modifier.modifiers, name, members, popJavadoc(), modifier.annotations);  }}InterfaceDeclaration InterfaceDeclaration(Modifier modifier) :{  String name = null;  List<TypeParameter> typePar = null;  List<ClassOrInterfaceType> extList = null;  List<BodyDeclaration> members = null;}{  "interface" < IDENTIFIER >  {    name = token.image;  }  [ typePar = TypeParameters() ] [ extList = ExtendsList(true) ] members = ClassOrInterfaceBody(true)  {    return NodeFacade.InterfaceDeclaration(typePar, extList, modifier.modifiers, name, members, popJavadoc(), modifier.annotations);  }}List<ClassOrInterfaceType> ExtendsList(boolean isInterface) :{  boolean extendsMoreThanOne = false;  List<ClassOrInterfaceType> ret = null;  ClassOrInterfaceType cit;  List<AnnotationExpr> ann = null;}{  "extends" ann = Annotations() cit = ClassOrInterfaceType()  {    cit.setAnnotations(NodeFacade.NodeList(ann));    ret = add(ret, cit);  }  (    "," ann = Annotations() cit = ClassOrInterfaceType()    {      cit.setAnnotations(NodeFacade.NodeList(ann));      ret = add(ret, cit);      extendsMoreThanOne = true;    }  )*  {    if (extendsMoreThanOne && !isInterface) throwParseException(token, "A class cannot extend more than one other class");  }  {    return ret;  }}List<ClassOrInterfaceType> ImplementsList(boolean isInterface) :{  List<ClassOrInterfaceType> ret = null;  ClassOrInterfaceType cit;  List<AnnotationExpr> ann = null;}{  "implements" ann = Annotations() cit = ClassOrInterfaceType()  {    cit.setAnnotations(NodeFacade.NodeList(ann));    ret = add(ret, cit);  }  (    "," ann = Annotations() cit = ClassOrInterfaceType()    {      cit.setAnnotations(NodeFacade.NodeList(ann));      ret = add(ret, cit);    }  )*  {    if (isInterface) throwParseException(token, "An interface cannot implement other interfaces");  }  {    return ret;  }}List<ClassOrInterfaceType> ThrowsList() :{  List<ClassOrInterfaceType> ret = null;  ClassOrInterfaceType cit;  List<AnnotationExpr> ann = null;}{  "throws" ann = Annotations() cit = ClassOrInterfaceType()  {    cit.setAnnotations(NodeFacade.NodeList(ann));    ret = add(ret, cit);  }  (    "," ann = Annotations() cit = ClassOrInterfaceType()    {      cit.setAnnotations(NodeFacade.NodeList(ann));      ret = add(ret, cit);    }  )*  {    return ret;  }}EnumDeclaration EnumDeclaration(Modifier modifier) :{  String name;  List<ClassOrInterfaceType> impList = null;  EnumConstantDeclaration entry;  List<EnumConstantDeclaration> entries = null;  BodyDeclaration member;  List<BodyDeclaration> members = null;}{  "enum" < IDENTIFIER >  {    name = token.image;  }  [ impList = ImplementsList(false) ] "{"  [    {      entries = new LinkedList<EnumConstantDeclaration>();    }    entry = EnumConstantDeclaration()    {      entries.add(entry);    }    (      LOOKAHEAD(2)      "," entry = EnumConstantDeclaration()      {        entries.add(entry);      }    )*  ]  [ "," ]  [    (      ";"      (        member = ClassOrInterfaceBodyDeclaration(false)        {          members = add(members, member);        }      )*    )  ]  "}"  {    return NodeFacade.EnumDeclaration(impList, entries, modifier.modifiers, name, members, popJavadoc(), modifier.annotations);  }}EnumConstantDeclaration EnumConstantDeclaration() :{  List<AnnotationExpr> annotations = null;  AnnotationExpr ann;  String name;  List<Expression> args = null;  List<BodyDeclaration> classBody = null;}{  {    pushJavadoc();  }  (    ann = Annotation()    {      annotations = add(annotations, ann);    }  )*  < IDENTIFIER >  {    name = token.image;  }  [ args = Arguments() ] [ classBody = ClassOrInterfaceBody(false) ]  {    return NodeFacade.EnumConstantDeclaration(name, args, classBody, popJavadoc(), annotations);  }}List<TypeParameter> TypeParameters() :{  List<TypeParameter> ret = null;  TypeParameter tp;}{  "<"  [    tp = TypeParameter()    {      ret = add(ret, tp);    }    (      "," tp = TypeParameter()      {        ret = add(ret, tp);      }    )*  ]  ">"  {    return ret;  }}TypeParameter TypeParameter() :{  String name;  List<ClassOrInterfaceType> typeBound = null;  List<AnnotationExpr> ann = null;}{  ann = Annotations()  < IDENTIFIER >  {    name = token.image;  }  [ typeBound = TypeBound() ]  {    return NodeFacade.TypeParameter(name, typeBound, ann);  }}List<ClassOrInterfaceType> TypeBound() :{  List<ClassOrInterfaceType> ret = null;  ClassOrInterfaceType cit;  List<AnnotationExpr> ann = null;}{  "extends" ann = Annotations() cit = ClassOrInterfaceType()  {    cit.setAnnotations(NodeFacade.NodeList(ann));    ret = add(ret, cit);  }  (    "&" ann = Annotations() cit = ClassOrInterfaceType()    {      cit.setAnnotations(NodeFacade.NodeList(ann));      ret = add(ret, cit);    }  )*  {    return ret;  }}List<BodyDeclaration> ClassOrInterfaceBody(boolean isInterface) :{  List<BodyDeclaration> ret = null;  BodyDeclaration member;}{  "{"  (    member = ClassOrInterfaceBodyDeclaration(isInterface)    {      ret = add(ret, member);    }  )*  "}"  {    return ret;  }}BodyDeclaration ClassOrInterfaceBodyDeclaration(boolean isInterface) :{  boolean isNestedInterface = false;  Modifier modifier;  BodyDeclaration ret;}{  {    pushJavadoc();  }  (    LOOKAHEAD(2)    ret = InitializerDeclaration()    {      if (isInterface) throwParseException(token, "An interface cannot have initializers");    }  | modifier = TypeDeclModifiers() // Just get all the modifiers out of the way. If you want to do
    // more checks, pass the modifiers down to the member
    (      ret = ClassOrInterfaceDeclaration(modifier)    | ret = EnumDeclaration(modifier)    | LOOKAHEAD(2) ret = AnnotationTypeDeclaration(modifier)    | LOOKAHEAD([ TypeParameters() ] < IDENTIFIER > "(")      ret = ConstructorDeclaration(modifier)    | LOOKAHEAD(Type() < IDENTIFIER > ("[" "]")* (","    | "="    | ";"))      ret = FieldDeclaration(modifier)    | ret = MethodDeclaration(modifier)    )  | ";"    {      ret = NodeFacade.EmptyMemberDeclaration(popJavadoc());    }  )  {    return ret;  }}FieldDeclaration FieldDeclaration(Modifier modifier) :{  Type type;  List<VariableDeclarator> variables = new LinkedList<VariableDeclarator>();  VariableDeclarator val;}{  // Modifiers are already matched in the caller
  type = TypeNoAnnotations() val = VariableDeclarator()  {    variables.add(val);  }  (    "," val = VariableDeclarator()    {      variables.add(val);    }  )*  ";"  {    return NodeFacade.FieldDeclaration(modifier.modifiers, type, variables, popJavadoc(), modifier.annotations);  }}VariableDeclarator VariableDeclarator() :{  VariableDeclaratorId id;  Expression init = null;}{  id = VariableDeclaratorId() [ "=" init = VariableInitializer() ]  {    return NodeFacade.VariableDeclarator(id, init);  }}VariableDeclaratorId VariableDeclaratorId() :{  String name;  List<AnnotationExpr> ann = null;  List<ArraySlot> slots = null;  ArraySlot slot = null;}{  ( < IDENTIFIER > | "this")  {    name = token.image;  }  (LOOKAHEAD(Annotations() "[" "]")    ann = Annotations() "[" "]"   {     slot = NodeFacade.ArraySlot(ann);     slots = add(slots, slot);   }  )*  {    return NodeFacade.VariableDeclaratorId(name, slots);  }}Expression VariableInitializer() :{  Expression ret;}{  (    ret = ArrayInitializer()  | ret = Expression()  )  {    return ret;  }}ArrayInitializerExpr ArrayInitializer() :{  List<Expression> values = null;  Expression val;}{  "{"  [    val = VariableInitializer()    {      values = add(values, val);    }    (      LOOKAHEAD(2)      "," val = VariableInitializer()      {        values = add(values, val);      }    )*  ]  [ "," ] "}"  {    return NodeFacade.ArrayInitializerExpr(values);  }}MethodDeclaration MethodDeclaration(Modifier modifier) :{  List<TypeParameter> typeParameters = null;  Type type;  String name;  List<Parameter> parameters;  int arrayCount = 0;  List<ClassOrInterfaceType> throws_ = null;  BlockStmt block = null;  List<AnnotationExpr> ann = null;  List<ArraySlot> slots = null;  ArraySlot slot = null;}{  // Modifiers already matched in the caller!
  [ typeParameters = TypeParameters() ] type = ResultType() < IDENTIFIER >  {    name = token.image;  }  parameters = FormalParameters()  ( ann = Annotations() "[" "]"   {     slot = NodeFacade.ArraySlot(ann);     slots = add(slots, slot);   }  )*  [ throws_ = ThrowsList() ]  (    block = Block()  | ";"  )  {    return NodeFacade.MethodDeclaration(modifier.modifiers, typeParameters, type, name, parameters,    	slots, throws_, block, popJavadoc(), modifier.annotations);  }}List<Parameter> FormalParameters() :{  List<Parameter> ret = null;  Parameter par;}{  "("  [    par = FormalParameter()    {      ret = add(ret, par);    }    (      "," par = FormalParameter()      {        ret = add(ret, par);      }    )*  ]  ")"  {    return ret;  }}Parameter FormalParameter() :{  Modifier modifier;  Type type;  VariableDeclaratorId id;  List<AnnotationExpr> ann = null;  Ellipsis ellipsis = null;}{  modifier = Modifiers() type = Type()  [    ann = Annotations() "..."    {      ellipsis = NodeFacade.Ellipsis(ann);    }  ]  id = VariableDeclaratorId()  {    return NodeFacade.Parameter(modifier.modifiers, type, ellipsis, id, modifier.annotations);  }}List<Parameter> LambdaParameters() :{  List<Parameter> ret = null;  Parameter par;}{  "("  [    par = LambdaParameter()    {      ret = add(ret, par);    }    (      "," par = LambdaParameter()      {        ret = add(ret, par);      }    )*  ]  ")"  {    return ret;  }}Parameter LambdaParameter() :{  String name = null;}{  < IDENTIFIER >  {    name = token.image;  }  {    return NodeFacade.Parameter(0, null, null, NodeFacade.VariableDeclaratorId(name, null), null);  }}ConstructorDeclaration ConstructorDeclaration(Modifier modifier) :{  List<TypeParameter> typeParameters = null;  String name;  List<Parameter> parameters;  List<ClassOrInterfaceType> throws_ = null;  ExplicitConstructorInvocationStmt exConsInv = null;  List<Statement> stmts;}{  [ typeParameters = TypeParameters() ] // Modifiers matched in the caller
  < IDENTIFIER >  {    name = token.image;  }  parameters = FormalParameters() [ "throws" throws_ = ThrowsList() ] "{"  [    LOOKAHEAD(ExplicitConstructorInvocation())    exConsInv = ExplicitConstructorInvocation()  ]  stmts = Statements() "}"  {    if (exConsInv != null)    {      stmts = add(0, stmts, exConsInv);    }    return NodeFacade.ConstructorDeclaration(modifier.modifiers, typeParameters, name, parameters,    	throws_, NodeFacade.BlockStmt(stmts), popJavadoc(), modifier.annotations);  }}ExplicitConstructorInvocationStmt ExplicitConstructorInvocation() :{  boolean isThis = false;  List<Expression> args;  Expression expr = null;  List<Type> typeArgs = null;}{  (    LOOKAHEAD([ TypeArguments() ] "this" "(")    [ typeArgs = TypeArguments()     ] "this"    {      isThis = true;    }    args = Arguments() ";"  |    [      LOOKAHEAD(PrimaryExpressionWithoutSuperSuffix() ".")      expr = PrimaryExpressionWithoutSuperSuffix() "."    ]    [ typeArgs = TypeArguments() ] "super" args = Arguments() ";"  )  {    return NodeFacade.ExplicitConstructorInvocationStmt(typeArgs, isThis, expr, args);  }}List<Statement> Statements() :{  List<Statement> ret = null;  Statement stmt;}{  (    stmt = BlockStatement()    {      ret = add(ret, stmt);    }  )*  {    return ret;  }}InitializerDeclaration InitializerDeclaration() :{  BlockStmt block;  boolean isStatic = false;}{  [    "static"    {      isStatic = true;    }  ]  block = Block()  {    return NodeFacade.InitializerDeclaration(isStatic, block, popJavadoc());  }}/*
 * Type, name and expression syntax follows.
 */Type Type() :{  Type ret;  List<AnnotationExpr> annotations = null;}{  annotations = Annotations()  (    LOOKAHEAD(2)    ret = ReferenceType()  | ret = PrimitiveType()  )  {    ret.setAnnotations(NodeFacade.NodeList(annotations));    return ret;  }}Type TypeNoAnnotations() :{  Type ret;}{  (    LOOKAHEAD(2)    ret = ReferenceType()  | ret = PrimitiveType()  )  {    return ret;  }}ReferenceType ReferenceType() :{  Type type;  List<ArraySlot> slots = null;  ArraySlot slot = null;  List<AnnotationExpr> annotations = null;}{  (    type = PrimitiveType()    (      LOOKAHEAD(Annotations() "[" "]")      annotations = Annotations() "[" "]"      {        slot = NodeFacade.ArraySlot(annotations);        slots = add(slots, slot);      }    )+  | type = ClassOrInterfaceType()    (      LOOKAHEAD(Annotations() "[" "]")      annotations = Annotations() "[" "]"      {        slot = NodeFacade.ArraySlot(annotations);        slots = add(slots, slot);      }    )*  )  {    return NodeFacade.ReferenceType(type, slots);  }}ClassOrInterfaceType ClassOrInterfaceType() :{  ClassOrInterfaceType ret;  NameExpr name;  List<Type> typeArgs = null;  List<AnnotationExpr> ann = null;}{  name = Name()  [    LOOKAHEAD(2)    typeArgs = TypeArguments()  ]  {    ret = toClassOrInterfaceType(name);    ret.setTypeArgs(NodeFacade.NodeList(typeArgs));    typeArgs = null;  }  (    LOOKAHEAD(2)    "." ann = Annotations() < IDENTIFIER >    {      name = NodeFacade.NameExpr(token.image);    }    [      LOOKAHEAD(2)      typeArgs = TypeArguments()    ]    {      ret = NodeFacade.ClassOrInterfaceType(ret, name, typeArgs, ann);    }  )*  {    return ret;  }}List<Type> TypeArguments() :{  List<Type> ret = new LinkedList<Type>();  Type type;}{  "<"  [    type = TypeArgument()    {      ret.add(type);    }    (      "," type = TypeArgument()      {        ret.add(type);      }    )*  ]  ">"  {    return ret;  }}Type TypeArgument() :{  Type ret;  List<AnnotationExpr> annotations = null; }{  annotations = Annotations()  (    ret = ReferenceType()  | ret = Wildcard()  )  {    ret.setAnnotations(NodeFacade.NodeList(annotations));    return ret;  }}WildcardType Wildcard() :{  ReferenceType ext = null;  ReferenceType sup = null;  List<AnnotationExpr> annotations = null;}{  "?"  [    "extends" annotations = Annotations() ext = ReferenceType()    {      ext.setAnnotations(NodeFacade.NodeList(annotations));    }  | "super" annotations = Annotations() sup = ReferenceType()    {      sup.setAnnotations(NodeFacade.NodeList(annotations));    }  ]  {    return NodeFacade.WildcardType(ext, sup);  }}PrimitiveType PrimitiveType() :{  PrimitiveType ret;}{  (    "boolean"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Boolean);    }  | "char"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Char);    }  | "byte"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Byte);    }  | "short"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Short);    }  | "int"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Int);    }  | "long"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Long);    }  | "float"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Float);    }  | "double"    {      ret = NodeFacade.PrimitiveType(PrimitiveType.Primitive.Double);    }  )  {    return ret;  }}Type ResultType() :{  Type ret;}{  (    "void"    {      ret = NodeFacade.VoidType();    }  | ret = Type()  )  {    return ret;  }}NameExpr Name() :/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */{  NameExpr ret;}{  < IDENTIFIER >  {    ret = NodeFacade.NameExpr(token.image);  }  (    LOOKAHEAD(2)    "." < IDENTIFIER >    {      ret = NodeFacade.QualifiedNameExpr(ret, token.image);    }  )*  {    return ret;  }}List<NameExpr> NameList() :{  List<NameExpr> ret = new LinkedList<NameExpr>();  NameExpr name;  List<AnnotationExpr> ann = null;}{  ann = Annotations() name = Name()  {    name.setAnnotations(NodeFacade.NodeList(ann));    ret.add(name);  }  (    "," ann = Annotations() name = Name()    {      name.setAnnotations(NodeFacade.NodeList(ann));      ret.add(name);    }  )*  {    return ret;  }}/*
 * Expression syntax follows.
 */Expression Expression() :/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */{  Expression ret;  AssignExpr.AssignOperator op;  Expression value;}{  ret = ConditionalExpression()  [    LOOKAHEAD(2)    op = AssignmentOperator() value = Expression()    {      ret = NodeFacade.AssignExpr(ret, value, op);    }  ]  {    return ret;  }}AssignExpr.AssignOperator AssignmentOperator() :{  AssignExpr.AssignOperator ret;}{  (    "="    {      ret = AssignExpr.AssignOperator.assign;    }  | "*="    {      ret = AssignExpr.AssignOperator.star;    }  | "/="    {      ret = AssignExpr.AssignOperator.slash;    }  | "%="    {      ret = AssignExpr.AssignOperator.rem;    }  | "+="    {      ret = AssignExpr.AssignOperator.plus;    }  | "-="    {      ret = AssignExpr.AssignOperator.minus;    }  | "<<="    {      ret = AssignExpr.AssignOperator.lShift;    }  | ">>="    {      ret = AssignExpr.AssignOperator.rSignedShift;    }  | ">>>="    {      ret = AssignExpr.AssignOperator.rUnsignedShift;    }  | "&="    {      ret = AssignExpr.AssignOperator.and;    }  | "^="    {      ret = AssignExpr.AssignOperator.xor;    }  | "|="    {      ret = AssignExpr.AssignOperator.or;    }  )  {    return ret;  }}Expression ConditionalExpression() :{  Expression ret;  Expression left;  Expression right;}{  ret = ConditionalOrExpression()  [    LOOKAHEAD(2)    "?" left = Expression() ":" right = ConditionalExpression()    {      ret = NodeFacade.ConditionalExpr(ret, left, right);    }  ]  {    return ret;  }}//Expression LambdaExpression() ://{//  Expression ret = null;//  Expression left = null;//  Expression right = null;//  BlockStmt blockStmt = null;//  NodeList<Parameter> pars = null;//  CastExpr expr = null;//}//{//  ret = ConditionalOrExpression()//  [//    "->"//    {//      if(ret instanceof NameExpr)//      {//        String name = ((NameExpr) ret).getName();//        pars = NodeFacade.NodeList(NodeFacade.Parameter(0, null, false, NodeFacade.VariableDeclaratorId(name, 0), null));//      } else if(ret instanceof Lambda)//      {//        pars = ((Lambda) ret).getParameters();//      } else if(ret instanceof CastExpr)//      {//        expr = (CastExpr) ret;//        pars = ((Lambda) expr.getExpression()).getParameters();//      } else//      {//        System.err.println(ret.getClass());//        throw new ParseException("LambdaExpression: " + ret.getClass().toString());//      }//    }//    (//      ret = Expression()//      {//        ret = NodeFacade.LambdaExpr(ret, pars);//      }//    | blockStmt = Block()//      {//        ret = NodeFacade.LambdaBlock(blockStmt, pars);//      }//    )//  ]//  {//    if(expr != null)//    {//      expr.setExpression(ret);//      ret = expr;//    }//    return ret;//  }//}Expression ConditionalOrExpression() :{  Expression ret;  Expression right;}{  ret = ConditionalAndExpression()  (    "||" right = ConditionalAndExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, BinaryExpr.BinaryOperator.or);    }  )*  {    return ret;  }}Expression ConditionalAndExpression() :{  Expression ret;  Expression right;}{  ret = InclusiveOrExpression()  (    "&&" right = InclusiveOrExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, BinaryExpr.BinaryOperator.and);    }  )*  {    return ret;  }}Expression InclusiveOrExpression() :{  Expression ret;  Expression right;}{  ret = ExclusiveOrExpression()  (    "|" right = ExclusiveOrExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, BinaryExpr.BinaryOperator.binOr);    }  )*  {    return ret;  }}Expression ExclusiveOrExpression() :{  Expression ret;  Expression right;}{  ret = AndExpression()  (    "^" right = AndExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, BinaryExpr.BinaryOperator.xor);    }  )*  {    return ret;  }}Expression AndExpression() :{  Expression ret;  Expression right;}{  ret = EqualityExpression()  (    "&" right = EqualityExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, BinaryExpr.BinaryOperator.binAnd);    }  )*  {    return ret;  }}Expression EqualityExpression() :{  Expression ret;  Expression right;  BinaryExpr.BinaryOperator op;}{  ret = InstanceOfExpression()  (    (      "=="      {        op = BinaryExpr.BinaryOperator.equals;      }    | "!="      {        op = BinaryExpr.BinaryOperator.notEquals;      }    )    right = InstanceOfExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, op);    }  )*  {    return ret;  }}Expression InstanceOfExpression() :{  Expression ret;  Type type;}{  ret = RelationalExpression()  [    "instanceof" type = Type()    {      ret = NodeFacade.InstanceOfExpr(ret, type);    }  ]  {    return ret;  }}Expression RelationalExpression() :{  Expression ret;  Expression right;  BinaryExpr.BinaryOperator op;}{  ret = ShiftExpression()  (    (      "<"      {        op = BinaryExpr.BinaryOperator.less;      }    | ">"      {        op = BinaryExpr.BinaryOperator.greater;      }    | "<="      {        op = BinaryExpr.BinaryOperator.lessEquals;      }    | ">="      {        op = BinaryExpr.BinaryOperator.greaterEquals;      }    )    right = ShiftExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, op);    }  )*  {    return ret;  }}Expression ShiftExpression() :{  Expression ret;  Expression right;  BinaryExpr.BinaryOperator op;}{  ret = AdditiveExpression()  (    (      "<<"      {        op = BinaryExpr.BinaryOperator.lShift;      }    | RSIGNEDSHIFT()      {        op = BinaryExpr.BinaryOperator.rSignedShift;      }    | RUNSIGNEDSHIFT()      {        op = BinaryExpr.BinaryOperator.rUnsignedShift;      }    )    right = AdditiveExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, op);    }  )*  {    return ret;  }}Expression AdditiveExpression() :{  Expression ret;  Expression right;  BinaryExpr.BinaryOperator op;}{  ret = MultiplicativeExpression()  (    (      "+"      {        op = BinaryExpr.BinaryOperator.plus;      }    | "-"      {        op = BinaryExpr.BinaryOperator.minus;      }    )    right = MultiplicativeExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, op);    }  )*  {    return ret;  }}Expression MultiplicativeExpression() :{  Expression ret;  Expression right;  BinaryExpr.BinaryOperator op;}{  ret = UnaryExpression()  (    (      "*"      {        op = BinaryExpr.BinaryOperator.times;      }    | "/"      {        op = BinaryExpr.BinaryOperator.divide;      }    | "%"      {        op = BinaryExpr.BinaryOperator.remainder;      }    )    right = UnaryExpression()    {      ret = NodeFacade.BinaryExpr(ret, right, op);    }  )*  {    return ret;  }}Expression UnaryExpression() :{  Expression ret;  UnaryExpr.UnaryOperator op;}{  (    ret = PreIncrementExpression()  | ret = PreDecrementExpression()  |    (      "+"      {        op = UnaryExpr.UnaryOperator.positive;      }    | "-"      {        op = UnaryExpr.UnaryOperator.negative;      }    )    ret = UnaryExpression()    {      ret = NodeFacade.UnaryExpr(ret, op);    }  | ret = UnaryExpressionNotPlusMinus()  )  {    return ret;  }}Expression PreIncrementExpression() :{  Expression ret;}{  "++" ret = UnaryExpression()  {    ret = NodeFacade.UnaryExpr(ret, UnaryExpr.UnaryOperator.preIncrement);  }  {    return ret;  }}Expression PreDecrementExpression() :{  Expression ret;}{  "--" ret = UnaryExpression()  {    ret = NodeFacade.UnaryExpr(ret, UnaryExpr.UnaryOperator.preDecrement);  }  {    return ret;  }}Expression UnaryExpressionNotPlusMinus() :{  Expression ret;  UnaryExpr.UnaryOperator op;}{  (    (      "~"      {        op = UnaryExpr.UnaryOperator.inverse;      }    | "!"      {        op = UnaryExpr.UnaryOperator.not;      }    )    ret = UnaryExpression()    {      ret = NodeFacade.UnaryExpr(ret, op);    }  | LOOKAHEAD(CastExpression())    ret = CastExpression()  | ret = PostfixExpression()  )  {    return ret;  }}Expression PostfixExpression() :{  Expression ret;  UnaryExpr.UnaryOperator op;}{  ret = PrimaryExpression()  [    LOOKAHEAD(2)    (      "++"      {        op = UnaryExpr.UnaryOperator.posIncrement;      }    | "--"      {        op = UnaryExpr.UnaryOperator.posDecrement;      }    )    {      ret = NodeFacade.UnaryExpr(ret, op);    }  ]  {    return ret;  }}Expression CastExpression() :{  Expression ret = null;  Type type = null;  List<Type> types = null;  List<AnnotationExpr> ann = null;}{  "("  ann = Annotations()  (    LOOKAHEAD(2)    type = PrimitiveType()    {      type.setAnnotations(NodeFacade.NodeList(ann));      types = add(types, type);    }    ( "&" ann = Annotations() type = PrimitiveType()     {       type.setAnnotations(NodeFacade.NodeList(ann));       types = add(types, type);     }    )*    ")" ret = UnaryExpression()    {      ret = NodeFacade.CastExpr(types, ret);    }  | type = ReferenceType()    {      type.setAnnotations(NodeFacade.NodeList(ann));      types = add(types, type);    }    ( "&" ann = Annotations() type = ReferenceType()     {       type.setAnnotations(NodeFacade.NodeList(ann));       types = add(types, type);     }    )*    ")" ret = UnaryExpressionNotPlusMinus()    {      ret = NodeFacade.CastExpr(types, ret);    }  )  {    return ret;  }}Expression PrimaryExpression() :{  Expression ret;  Expression inner;}{  ret = PrimaryPrefix()  (    LOOKAHEAD(2)    ret = PrimarySuffix(ret)  )*  {    return ret;  }}Expression PrimaryExpressionWithoutSuperSuffix() :{  Expression ret;  Expression inner;}{  ret = PrimaryPrefix()  (    LOOKAHEAD(PrimarySuffixWithoutSuper(null))    ret = PrimarySuffixWithoutSuper(ret)  )*  {    return ret;  }}Expression PrimaryPrefix() :{  Expression ret = null;  BlockStmt blockStmt = null;  String name = null;  List<Type> typeArgs = null;  List<Expression> args = null;  List<Parameter> pars = null;  boolean hasArgs = false;  boolean isArrow = false;  Type type = null;  Parameter par = null;}{  (    ret = Literal()  | "this"    {      ret = NodeFacade.ThisExpr();    }  | "super"    {      ret = NodeFacade.SuperExpr();    }    (      "." [ typeArgs = TypeArguments() ]      < IDENTIFIER >      {        name = token.image;      }      [        args = Arguments()        {          hasArgs = true;        }      ]      {        ret = hasArgs ? NodeFacade.MethodCallExpr(ret, typeArgs, name, args) : NodeFacade.FieldAccessExpr(ret, null, name);      }    | "::" [typeArgs = TypeArguments()] (< IDENTIFIER > | < NEW >)      {        ret = NodeFacade.MethodExprRef(ret, typeArgs, token.image);      }    )  | LOOKAHEAD(pars = FormalParameters() "->")     pars = FormalParameters() "->"     (       blockStmt = Block()       {         ret = NodeFacade.LambdaBlock(blockStmt, NodeFacade.NodeList(pars));       }     | ret = Expression()       {         ret = NodeFacade.LambdaExpr(ret, NodeFacade.NodeList(pars));       }     )  | LOOKAHEAD(pars = LambdaParameters() "->")     pars = LambdaParameters() "->"     (       blockStmt = Block()       {         ret = NodeFacade.LambdaBlock(blockStmt, NodeFacade.NodeList(pars));       }     | ret = Expression()       {         ret = NodeFacade.LambdaExpr(ret, NodeFacade.NodeList(pars));       }     )  | "(" ret = Expression() ")"    {      ret = NodeFacade.EnclosedExpr(ret);    }  | ret = AllocationExpression(null)  | LOOKAHEAD(ResultType() "." "class")    type = ResultType() "." "class"    {      ret = NodeFacade.ClassExpr(type);    }  | LOOKAHEAD(ResultType() "::")    type = ResultType() "::" [typeArgs = TypeArguments()] (< IDENTIFIER > | < NEW >)    {      ret = NodeFacade.MethodTypeRef(type, typeArgs, token.image);    }  | < IDENTIFIER >    {      name = token.image;    }    [      "->"      {        isArrow = true;        pars = NodeFacade.NodeList(NodeFacade.Parameter(0, null, null, NodeFacade.VariableDeclaratorId(name, null), null));      }     (       blockStmt = Block()       {         ret = NodeFacade.LambdaBlock(blockStmt, NodeFacade.NodeList(pars));       }     | ret = Expression()       {         ret = NodeFacade.LambdaExpr(ret, NodeFacade.NodeList(pars));       }     )     |       args = Arguments()      {        hasArgs = true;      }    ]    {      if(isArrow)      {        return ret;      } else      {        ret = hasArgs ? NodeFacade.MethodCallExpr(null, null, name, args) : NodeFacade.NameExpr(name);      }    }  )  {    return ret;  }}Expression PrimarySuffix(Expression scope) :{  Expression ret;}{  (    LOOKAHEAD(2)    ret = PrimarySuffixWithoutSuper(scope)  | "." "super"    {      ret = NodeFacade.SuperExpr(scope);    }  )  {    return ret;  }}Expression PrimarySuffixWithoutSuper(Expression scope) :{  Expression ret = null;  List<Type> typeArgs = null;  NodeList<Parameter> pars = null;  List<Expression> args = null;  boolean hasArgs = false;  String name = null;}{  (    "::" [typeArgs = TypeArguments()] (< IDENTIFIER > | < NEW >)    {      ret = NodeFacade.MethodExprRef(scope, typeArgs, token.image);    }  |     "."    (      // TODO:
      "this"      {        ret = NodeFacade.ThisExpr(scope);      }    | ret = AllocationExpression(scope)    | LOOKAHEAD([ TypeArguments() ] < IDENTIFIER >)      [ typeArgs = TypeArguments() ] < IDENTIFIER >      {        name = token.image;      }      [        args = Arguments()        {          hasArgs = true;        }      ]      {        ret = hasArgs ? NodeFacade.MethodCallExpr(scope, typeArgs, name, args) : NodeFacade.FieldAccessExpr(scope, typeArgs, name);      }    )  | "[" ret = Expression() "]"    {      ret = NodeFacade.ArrayAccessExpr(scope, ret);    }  )   {    return ret;  }}Expression Literal() :{  Expression ret;}{  (    < INTEGER_LITERAL >    {      ret = NodeFacade.IntegerLiteralExpr(token.image);    }  | < LONG_LITERAL >    {      ret = NodeFacade.LongLiteralExpr(token.image);    }  | < FLOATING_POINT_LITERAL >    {      ret = NodeFacade.DoubleLiteralExpr(token.image);    }  | < CHARACTER_LITERAL >    {      ret = NodeFacade.CharLiteralExpr(token.image);    }  | < STRING_LITERAL >    {      ret = NodeFacade.StringLiteralExpr(token.image.substring(1, token.image.length() - 1));    }  | ret = BooleanLiteral()  | ret = NullLiteral()  )  {    return ret;  }}Expression BooleanLiteral() :{  Expression ret;}{  (    "true"    {      ret = NodeFacade.BooleanLiteralExpr(true);    }  | "false"    {      ret = NodeFacade.BooleanLiteralExpr(false);    }  )  {    return ret;  }}Expression NullLiteral() :{}{  "null"  {    return NodeFacade.NullLiteralExpr();  }}List<Expression> Arguments() :{  List<Expression> ret = null;}{  "(" [ ret = ArgumentList() ] ")"  {    return ret;  }}List<Expression> ArgumentList() :{  List<Expression> ret = new LinkedList<Expression>();  Expression expr;}{  expr = Expression()  {    ret.add(expr);  }  (    "," expr = Expression()    {      ret.add(expr);    }  )*  {    return ret;  }}Expression AllocationExpression(Expression scope) :{  Expression ret;  Type type;  ArrayDimsAndInits arr = null;  List<Type> typeArgs = null;  List<BodyDeclaration> anonymousBody = null;  List<Expression> args;  List<AnnotationExpr> ann = null;}{  "new"  ann = Annotations()  (    type = PrimitiveType() arr = ArrayDimsAndInits()    {      ret = NodeFacade.ArrayCreationExpr(type, arr.slots, arr.initializer);    }  | LOOKAHEAD(ClassOrInterfaceType() ArrayDimsAndInits())    type = ClassOrInterfaceType() arr = ArrayDimsAndInits()    {      ret = NodeFacade.ArrayCreationExpr(type, arr.slots, arr.initializer);    }  | [ typeArgs = TypeArguments() ] type = ClassOrInterfaceType() args = Arguments()    [      LOOKAHEAD(2)      anonymousBody = ClassOrInterfaceBody(false)    ]    {      ret = NodeFacade.ObjectCreationExpr(scope, (ClassOrInterfaceType) type, typeArgs, args, anonymousBody);    }  )  {    type.setAnnotations(NodeFacade.NodeList(ann));    return ret;  }}/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */ArrayDimsAndInits ArrayDimsAndInits() :{  ArrayDimsAndInits ret = null;  ArrayInitializerExpr initializer = null;  Expression expression = null;  List<ArraySlot> slots = null;  ArraySlot slot = null;  List<AnnotationExpr> ann = null;}{   (    LOOKAHEAD(Annotations() "[" "]")    (ann = Annotations() "[" "]"    {      slot = NodeFacade.ArraySlot(ann);      slots = add(slots, slot);    }    )+    initializer = ArrayInitializer()    {      ret = new ArrayDimsAndInits(slots, initializer);    }  | (      LOOKAHEAD(Annotations() "[" Expression())      ann = Annotations() "[" expression = Expression()      {        slot = NodeFacade.ArraySlot(expression, ann);        slots = add(slots, slot);      }      "]"    )+    (      LOOKAHEAD(Annotations() "[" "]")      ann = Annotations() "[" "]"      {        slot = NodeFacade.ArraySlot(ann);        slots = add(slots, slot);      }    )*    {      ret = new ArrayDimsAndInits(slots, initializer);    }  )  {    return ret;  }}/*
 * Statement syntax follows.
 */Statement Statement() :{  Statement ret = null;}{  (    LOOKAHEAD(2)    ret = LabeledStatement()  | ret = AssertStatement()  | ret = Block()  | ret = EmptyStatement()  | ret = StatementExpression()  | ret = SwitchStatement()  | ret = IfStatement()  | ret = WhileStatement()  | ret = DoStatement()  | ret = ForStatement()  | ret = BreakStatement()  | ret = ContinueStatement()  | ret = ReturnStatement()  | ret = ThrowStatement()  | ret = SynchronizedStatement()  | ret = TryStatement()  )  {    return ret;  }}AssertStmt AssertStatement() :{  Expression check;  Expression msg = null;}{  "assert" check = Expression() [ ":" msg = Expression() ] ";"  {    return NodeFacade.AssertStmt(check, msg);  }}LabeledStmt LabeledStatement() :{  String label;  Statement stmt;}{  < IDENTIFIER >  {    label = token.image;  }  ":" stmt = Statement()  {    return NodeFacade.LabeledStmt(label, stmt);  }}BlockStmt Block() :{  List<Statement> stmts;}{  "{" stmts = Statements() "}"  {    return NodeFacade.BlockStmt(stmts);  }}/*
 * Classes inside block stametents can only be abstract or final. The semantic must check it.
 */Statement BlockStatement() :{  Statement ret;  Expression expr;  TypeDeclaration typeDecl;  Modifier modifier;}{  (    LOOKAHEAD(Modifiers() ("class"  | "interface"))    {      pushJavadoc();    }    modifier = Modifiers() typeDecl = ClassOrInterfaceDeclaration(modifier)    {      ret = NodeFacade.TypeDeclarationStmt(typeDecl);    }  | LOOKAHEAD(VariableDeclarationExpression() ";")    expr = VariableDeclarationExpression() ";"    {      ret = NodeFacade.ExpressionStmt(expr);    }  | ret = Statement()  )  {    return ret;  }}VariableDeclarationExpr VariableDeclarationExpression() :{  Modifier modifier = null;  Type type = null;  List<VariableDeclarator> vars = new LinkedList<VariableDeclarator>();  VariableDeclarator var = null;}{  modifier = Modifiers() type = TypeNoAnnotations() var = VariableDeclarator()  {    vars.add(var);  }  (    "," var = VariableDeclarator()    {      vars.add(var);    }  )*  {    return NodeFacade.VariableDeclarationExpr(modifier.modifiers, type, vars, modifier.annotations);  }}EmptyStmt EmptyStatement() :{}{  ";"  {    return NodeFacade.EmptyStmt();  }}ExpressionStmt StatementExpression() :/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */{  Expression expr;  AssignExpr.AssignOperator op;  Expression value;}{  (    expr = PreIncrementExpression()  | expr = PreDecrementExpression()  | expr = PrimaryExpression()    [      "++"      {        expr = NodeFacade.UnaryExpr(expr, UnaryExpr.UnaryOperator.posIncrement);      }    | "--"      {        expr = NodeFacade.UnaryExpr(expr, UnaryExpr.UnaryOperator.posDecrement);      }    | op = AssignmentOperator() value = Expression()      {        expr = NodeFacade.AssignExpr(expr, value, op);      }    ]  )  ";"  {    return NodeFacade.ExpressionStmt(expr);  }}SwitchStmt SwitchStatement() :{  Expression selector;  SwitchEntryStmt entry;  List<SwitchEntryStmt> entries = null;}{  "switch" "(" selector = Expression() ")" "{"  (    entry = SwitchEntry()    {      entries = add(entries, entry);    }  )*  "}"  {    return NodeFacade.SwitchStmt(selector, entries);  }}SwitchEntryStmt SwitchEntry() :{  Expression label = null;  List<Statement> stmts;}{  (    "case" label = Expression()  | "default"  )  ":" stmts = Statements()  {    return NodeFacade.SwitchEntryStmt(label, stmts);  }}IfStmt IfStatement() :/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */{  Expression condition;  Statement thenStmt;  Statement elseStmt = null;}{  "if" "(" condition = Expression() ")" thenStmt = Statement()  [    LOOKAHEAD(1)    "else" elseStmt = Statement()  ]  {    return NodeFacade.IfStmt(condition, thenStmt, elseStmt);  }}WhileStmt WhileStatement() :{  Expression condition;  Statement body;}{  "while" "(" condition = Expression() ")" body = Statement()  {    return NodeFacade.WhileStmt(condition, body);  }}DoStmt DoStatement() :{  Expression condition;  Statement body;}{  "do" body = Statement() "while" "(" condition = Expression() ")" ";"  {    return NodeFacade.DoStmt(body, condition);  }}Statement ForStatement() :{  String id = null;  VariableDeclarationExpr varExpr = null;  Expression expr = null;  List<Expression> init = null;  List<Expression> update = null;  Statement body;}{  "for" "("  (    LOOKAHEAD(VariableDeclarationExpression() ":")    varExpr = VariableDeclarationExpression() ":" expr = Expression()  | [ init = ForInit() ] ";" [ expr = Expression() ] ";" [ update = ForUpdate() ]  )  ")" body = Statement()  {    if (varExpr != null)    {      return NodeFacade.ForeachStmt(varExpr, expr, body);    }    return NodeFacade.ForStmt(init, expr, update, body);  }}List<Expression> ForInit() :{  List<Expression> ret;  Expression expr;}{  (    LOOKAHEAD(Modifiers() Type() < IDENTIFIER >)    expr = VariableDeclarationExpression()    {      ret = new LinkedList<Expression>();      ret.add(expr);    }  | ret = ExpressionList()  )  {    return ret;  }}List<Expression> ExpressionList() :{  List<Expression> ret = new LinkedList<Expression>();  Expression expr;}{  expr = Expression()  {    ret.add(expr);  }  (    "," expr = Expression()    {      ret.add(expr);    }  )*  {    return ret;  }}List<Expression> ForUpdate() :{  List<Expression> ret;}{  ret = ExpressionList()  {    return ret;  }}BreakStmt BreakStatement() :{  String id = null;}{  "break"  [    < IDENTIFIER >    {      id = token.image;    }  ]  ";"  {    return NodeFacade.BreakStmt(id);  }}ContinueStmt ContinueStatement() :{  String id = null;}{  "continue"  [    < IDENTIFIER >    {      id = token.image;    }  ]  ";"  {    return NodeFacade.ContinueStmt(id);  }}ReturnStmt ReturnStatement() :{  Expression expr = null;}{  "return" [ expr = Expression() ] ";"  {    return NodeFacade.ReturnStmt(expr);  }}ThrowStmt ThrowStatement() :{  Expression expr;}{  "throw" expr = Expression() ";"  {    return NodeFacade.ThrowStmt(expr);  }}SynchronizedStmt SynchronizedStatement() :{  Expression expr;  BlockStmt block;}{  "synchronized" "(" expr = Expression() ")" block = Block()  {    return NodeFacade.SynchronizedStmt(expr, block);  }}TryStmt TryStatement() :/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */{  BlockStmt tryBlock;  BlockStmt finallyBlock = null;  List<CatchClause> catchs = null;  Parameter except = null;  BlockStmt catchBlock = null;  List<VariableDeclarationExpr> resources = null;  VariableDeclarationExpr resource = null;  List<Type> types = null;  Type type = null;  String name = null;  boolean isFinal = false;}{  "try"  [ "("    (      resource = VariableDeclarationExpression()      {       resources = add(resources, resource);      }      [";"]    )*    ")"  ]  tryBlock = Block()    (      "catch" "("      [       "final"       {         isFinal = true;       }      ]      type = Type()      {        types = add(types, type);      }      (        "|" type = Type()        {          types = add(types, type);        }      )*      <IDENTIFIER>      {        name = token.image;      }      ")"      catchBlock = Block()      {        catchs = add(catchs, NodeFacade.CatchClause(isFinal, types, name, catchBlock));        types = null;      }    )*  [ "finally" finallyBlock = Block() ]  {    return NodeFacade.TryStmt(resources, tryBlock, catchs, finallyBlock);  }}/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */void RUNSIGNEDSHIFT() :{}{  (    LOOKAHEAD({ getToken(1).kind == GT && ((GTToken) getToken(1)).realKind == RUNSIGNEDSHIFT })    ">" ">" ">"  )}void RSIGNEDSHIFT() :{}{  (    LOOKAHEAD({ getToken(1).kind == GT && ((GTToken) getToken(1)).realKind == RSIGNEDSHIFT })    ">" ">"  )}/* Annotation syntax follows. */AnnotationExpr Annotation() :{  AnnotationExpr ret;}{  (    LOOKAHEAD("@" Name() "(" (< IDENTIFIER > "="  | ")"))    ret = NormalAnnotation()  | LOOKAHEAD("@" Name() "(")    ret = SingleMemberAnnotation()  | ret = MarkerAnnotation()  )  {    return ret;  }}List<AnnotationExpr>  Annotations() :{  List<AnnotationExpr> annotations = null;  AnnotationExpr ann;}{  (    ann = Annotation()    {      annotations = add(annotations, ann);    }  )*  {    return annotations;  }}NormalAnnotationExpr NormalAnnotation() :{  NameExpr name;  List<MemberValuePair> pairs = null;}{  "@" name = Name() "(" [ pairs = MemberValuePairs() ] ")"  {    return NodeFacade.NormalAnnotationExpr(pairs, name);  }}MarkerAnnotationExpr MarkerAnnotation() :{  NameExpr name;}{  "@" name = Name()  {    return NodeFacade.MarkerAnnotationExpr(name);  }}SingleMemberAnnotationExpr SingleMemberAnnotation() :{  NameExpr name;  Expression memberVal;}{  "@" name = Name() "(" memberVal = MemberValue() ")"  {    return NodeFacade.SingleMemberAnnotationExpr(memberVal, name);  }}List<MemberValuePair> MemberValuePairs() :{  List<MemberValuePair> ret = new LinkedList<MemberValuePair>();  MemberValuePair pair;}{  pair = MemberValuePair()  {    ret.add(pair);  }  (    "," pair = MemberValuePair()    {      ret.add(pair);    }  )*  {    return ret;  }}MemberValuePair MemberValuePair() :{  String name;  Expression value;}{  < IDENTIFIER >  {    name = token.image;  }  "=" value = MemberValue()  {    return NodeFacade.MemberValuePair(name, value);  }}Expression MemberValue() :{  Expression ret;}{  (    LOOKAHEAD(3)    ret = Annotation()  | ret = MemberValueArrayInitializer()  | ret = ConditionalExpression()  )  {    return ret;  }}Expression MemberValueArrayInitializer() :{  List<Expression> ret = null;  Expression member;}{  "{"  (    member = MemberValue()    {      ret = add(ret, member);    }    (      LOOKAHEAD(2)      "," member = MemberValue()      {        ret = add(ret, member);      }    )*  )?  [ "," ] "}"  {    return NodeFacade.ArrayInitializerExpr(ret);  }}/* Annotation Types. */AnnotationDeclaration AnnotationTypeDeclaration(Modifier modifier) :{  String name;  List<BodyDeclaration> members;}{  "@" "interface" < IDENTIFIER >  {    name = token.image;  }  members = AnnotationTypeBody()  {    return NodeFacade.AnnotationDeclaration(modifier.modifiers, name, members, popJavadoc(), modifier.annotations);  }}List<BodyDeclaration> AnnotationTypeBody() :{  List<BodyDeclaration> ret = null;  BodyDeclaration member;}{  "{"  (    member = AnnotationBodyDeclaration()    {      ret = add(ret, member);    }  )*  "}"  {    return ret;  }}BodyDeclaration AnnotationBodyDeclaration() :{  Modifier modifier;  BodyDeclaration ret;}{  {    pushJavadoc();  }  (    ";"    {      ret = NodeFacade.EmptyTypeDeclaration(popJavadoc());    }  | modifier = Modifiers()    (      LOOKAHEAD(Type() < IDENTIFIER > "(")      ret = AnnotationTypeMemberDeclaration(modifier)    | ret = ClassOrInterfaceDeclaration(modifier)    | ret = EnumDeclaration(modifier)    | LOOKAHEAD(2) ret = AnnotationTypeDeclaration(modifier)    | ret = FieldDeclaration(modifier)    )  )  {    return ret;  }}AnnotationMemberDeclaration AnnotationTypeMemberDeclaration(Modifier modifier) :{  Type type;  String name;  Expression defaultVal = null;}{  type = Type() < IDENTIFIER >  {    name = token.image;  }  "(" ")" [ defaultVal = DefaultValue() ] ";"  {    return NodeFacade.AnnotationMemberDeclaration(modifier.modifiers, type, name, defaultVal, popJavadoc(), modifier.annotations);  }}Expression DefaultValue() :{  Expression ret;}{  "default" ret = MemberValue()  {    return ret;  }}
